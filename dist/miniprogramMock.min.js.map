{"version":3,"file":"miniprogramMock.min.js","sources":["../src/miniprogramMock.ts"],"sourcesContent":["interface IMockOptions {\n  /**\n   * 接口别名，用来保证唯一性\n   */\n  aliasName?: string;\n  apiOptions?: any;\n\n  [key: string]: any;\n}\n\nif (global.wx) {\n  global.wx = {\n    ...global.wx,\n  };\n} else {\n  global.wx = {};\n}\n\nconst cache: any = {};\n\nclass MockWxApi {\n  private cacheKey = \"no key\";\n  private resData = null;\n  private errData = null;\n\n  constructor(apiName: string, options?: IMockOptions) {\n    if (options) {\n      this.cacheKey = `${apiName}.${JSON.stringify(options)}`;\n    }\n    this.cacheKey = apiName;\n    cache[this.cacheKey] = {\n      apiName,\n    };\n\n    global.wx[apiName] = jest.fn().mockImplementation((apiOptions) => {\n      const success =\n        apiOptions && apiOptions.success\n          ? apiOptions.success\n          : () => {\n              // do nothing\n            };\n      const fail =\n        apiOptions && apiOptions.fail\n          ? apiOptions.fail\n          : () => {\n              // do nothing\n            };\n      const complete =\n        apiOptions && apiOptions.complete\n          ? apiOptions.complete\n          : () => {\n              // do nothing\n            };\n\n      if (this.resData) {\n        const resData = cache[this.cacheKey].resData;\n        if (typeof resData === \"function\") {\n          success(resData());\n        } else {\n          success(cache[this.cacheKey].resData);\n        }\n        complete();\n      }\n\n      if (this.errData) {\n        const errData = cache[this.cacheKey].errData;\n        if (typeof errData === \"function\") {\n          fail(errData());\n        } else {\n          fail(cache[this.cacheKey].errData);\n        }\n        complete();\n      }\n    });\n  }\n\n  name(aliasName: string) {\n    this.cacheKey = aliasName;\n    return this;\n  }\n\n  success(res: any) {\n    if (typeof res === \"undefined\" || res === null) {\n      this.resData = null;\n    } else {\n      this.resData = res;\n    }\n\n    cache[this.cacheKey].resData = this.resData;\n    return global.wx[cache[this.cacheKey].apiName];\n  }\n\n  fail(err: any) {\n    if (typeof err === \"undefined\" || err === null) {\n      this.errData = null;\n    } else {\n      this.errData = err;\n    }\n\n    cache[this.cacheKey].errData = this.errData;\n    return global.wx[cache[this.cacheKey].apiName];\n  }\n}\n\nclass Mock {\n  mock(apiName: string, options?: IMockOptions) {\n    return new MockWxApi(apiName, options);\n  }\n}\n\nexport default Mock;\n"],"names":["global","wx","cache","apiName","options","this","cacheKey","JSON","stringify","jest","fn","mockImplementation","apiOptions","success","fail","complete","_this","resData","errData","MockWxApi","aliasName","res","err","Mock"],"mappings":";;;;;;;;;;;;;;mSAUIA,OAAOC,GACTD,OAAOC,QACFD,OAAOC,IAGZD,OAAOC,GAAK,GAGd,IAAMC,EAAa,gBAOjB,WAAYC,EAAiBC,GAA7B,WAJQC,cAAW,SACXA,aAAU,KACVA,aAAU,KAGZD,IACFC,KAAKC,SAAcH,MAAWI,KAAKC,UAAUJ,IAE/CC,KAAKC,SAAWH,EAChBD,EAAMG,KAAKC,UAAY,CACrBH,WAGFH,OAAOC,GAAGE,GAAWM,KAAKC,KAAKC,oBAAmB,SAACC,GACjD,IAAMC,EACJD,GAAcA,EAAWC,QACrBD,EAAWC,QACX,aAGAC,EACJF,GAAcA,EAAWE,KACrBF,EAAWE,KACX,aAGAC,EACJH,GAAcA,EAAWG,SACrBH,EAAWG,SACX,aAIN,GAAIC,EAAKC,QAAS,CAChB,IAAMA,EAAUf,EAAMc,EAAKV,UAAUW,QAEnCJ,EADqB,mBAAZI,EACDA,IAEAf,EAAMc,EAAKV,UAAUW,SAE/BF,IAGF,GAAIC,EAAKE,QAAS,CAChB,IAAMA,EAAUhB,EAAMc,EAAKV,UAAUY,QAEnCJ,EADqB,mBAAZI,EACJA,IAEAhB,EAAMc,EAAKV,UAAUY,SAE5BH,QA+BR,OA1BEI,iBAAA,SAAKC,GAEH,OADAf,KAAKC,SAAWc,EACTf,MAGTc,oBAAA,SAAQE,GAQN,OANEhB,KAAKY,QADH,MAAOI,EACM,KAEAA,EAGjBnB,EAAMG,KAAKC,UAAUW,QAAUZ,KAAKY,QAC7BjB,OAAOC,GAAGC,EAAMG,KAAKC,UAAUH,UAGxCgB,iBAAA,SAAKG,GAQH,OANEjB,KAAKa,QADH,MAAOI,EACM,KAEAA,EAGjBpB,EAAMG,KAAKC,UAAUY,QAAUb,KAAKa,QAC7BlB,OAAOC,GAAGC,EAAMG,KAAKC,UAAUH,4BAI1C,cAIA,OAHEoB,iBAAA,SAAKpB,EAAiBC,GACpB,OAAO,IAAIe,EAAUhB,EAASC"}