{"version":3,"file":"miniprogramMock.min.js","sources":["../src/miniprogramMock.ts"],"sourcesContent":["interface IMockOptions {\n  /**\n   * 接口别名，用来保证唯一性\n   */\n  aliasName?: string;\n  apiOptions?: any;\n\n  [key: string]: any;\n}\n\nconst cache: any = {};\n\nclass MockWxApi {\n  private cacheKey = \"no key\";\n  private resData = null;\n  private errData = null;\n\n  constructor(apiName: string, options?: IMockOptions) {\n    if (options) {\n      this.cacheKey = `${apiName}.${JSON.stringify(options)}`;\n    }\n    this.cacheKey = apiName;\n    cache[this.cacheKey] = {\n      apiName,\n    };\n\n    global.wx[apiName] = jest.fn().mockImplementation((apiOptions) => {\n      const success =\n        apiOptions && apiOptions.success\n          ? apiOptions.success\n          : () => {\n              // do nothing\n            };\n      const fail =\n        apiOptions && apiOptions.fail\n          ? apiOptions.fail\n          : () => {\n              // do nothing\n            };\n      const complete =\n        apiOptions && apiOptions.complete\n          ? apiOptions.complete\n          : () => {\n              // do nothing\n            };\n\n      if (this.resData) {\n        const resData = cache[this.cacheKey].resData;\n        if (typeof resData === \"function\") {\n          success(resData());\n        } else {\n          success(cache[this.cacheKey].resData);\n        }\n        complete();\n      }\n\n      if (this.errData) {\n        const errData = cache[this.cacheKey].errData;\n        if (typeof errData === \"function\") {\n          fail(errData());\n        } else {\n          fail(cache[this.cacheKey].errData);\n        }\n        complete();\n      }\n    });\n  }\n\n  name(aliasName: string) {\n    this.cacheKey = aliasName;\n    return this;\n  }\n\n  success(res: any) {\n    if (typeof res === \"undefined\" || res === null) {\n      this.resData = null;\n    } else {\n      this.resData = res;\n    }\n\n    cache[this.cacheKey].resData = this.resData;\n    return global.wx[cache[this.cacheKey].apiName];\n  }\n\n  fail(err: any) {\n    if (typeof err === \"undefined\" || err === null) {\n      this.errData = null;\n    } else {\n      this.errData = err;\n    }\n\n    cache[this.cacheKey].errData = this.errData;\n    return global.wx[cache[this.cacheKey].apiName];\n  }\n}\n\nclass Mock {\n  mock(apiName: string, options?: IMockOptions) {\n    return new MockWxApi(apiName, options);\n  }\n}\n\nexport default Mock;\n"],"names":["cache","apiName","options","this","cacheKey","JSON","stringify","global","wx","jest","fn","mockImplementation","apiOptions","success","fail","complete","_this","resData","errData","MockWxApi","aliasName","res","err","Mock"],"mappings":"uPAUA,IAAMA,EAAa,gBAOjB,WAAYC,EAAiBC,GAA7B,WAJQC,cAAW,SACXA,aAAU,KACVA,aAAU,KAGZD,IACFC,KAAKC,SAAcH,MAAWI,KAAKC,UAAUJ,IAE/CC,KAAKC,SAAWH,EAChBD,EAAMG,KAAKC,UAAY,CACrBH,WAGFM,OAAOC,GAAGP,GAAWQ,KAAKC,KAAKC,oBAAmB,SAACC,GACjD,IAAMC,EACJD,GAAcA,EAAWC,QACrBD,EAAWC,QACX,aAGAC,EACJF,GAAcA,EAAWE,KACrBF,EAAWE,KACX,aAGAC,EACJH,GAAcA,EAAWG,SACrBH,EAAWG,SACX,aAIN,GAAIC,EAAKC,QAAS,CAChB,IAAMA,EAAUjB,EAAMgB,EAAKZ,UAAUa,QAEnCJ,EADqB,mBAAZI,EACDA,IAEAjB,EAAMgB,EAAKZ,UAAUa,SAE/BF,IAGF,GAAIC,EAAKE,QAAS,CAChB,IAAMA,EAAUlB,EAAMgB,EAAKZ,UAAUc,QAEnCJ,EADqB,mBAAZI,EACJA,IAEAlB,EAAMgB,EAAKZ,UAAUc,SAE5BH,QA+BR,OA1BEI,iBAAA,SAAKC,GAEH,OADAjB,KAAKC,SAAWgB,EACTjB,MAGTgB,oBAAA,SAAQE,GAQN,OANElB,KAAKc,QADH,MAAOI,EACM,KAEAA,EAGjBrB,EAAMG,KAAKC,UAAUa,QAAUd,KAAKc,QAC7BV,OAAOC,GAAGR,EAAMG,KAAKC,UAAUH,UAGxCkB,iBAAA,SAAKG,GAQH,OANEnB,KAAKe,QADH,MAAOI,EACM,KAEAA,EAGjBtB,EAAMG,KAAKC,UAAUc,QAAUf,KAAKe,QAC7BX,OAAOC,GAAGR,EAAMG,KAAKC,UAAUH,4BAI1C,cAIA,OAHEsB,iBAAA,SAAKtB,EAAiBC,GACpB,OAAO,IAAIiB,EAAUlB,EAASC"}